package com.soham.Anuj_Prime3;

import java.util.*;

public class Array {
    public static void main(String[] args) {
//        int[]arr = {1,2,3,4,5};
//        int[]b = {2,3};
//
//        rotateK(arr,3);
//
////        int[]ans= new int[a.length*2];
////        for (int i = 0; i < a.length; i++) {
////            ans[i] = a[i];                 // Copy the first occurrence
////            ans[i+a.length] = a[i];   // Copy the second occurrence
////        }
//        int[] ans = Arrays.copyOf(arr, arr.length * 2);
//        System.arraycopy(arr, 0, ans, arr.length, arr.length);


//        ArrayList<Integer>a = new ArrayList<>(Arrays.asList(2,4,3,1,7,5,6));
//        System.out.println(waveNonLexo(a));

//        int[]arr={12,9,8,2,11};
//        System.out.println(minimumAbsDifference(arr));

//        int[]arr={1,2,1,0,0,2,1,0,2,1,0,2,1,0};
//        System.out.println(Arrays.toString(DNFsort(arr)));

//        int[]arr = {3,4,5,2,0,1,6};
//        System.out.println(maxChunksToSorted(arr));

//        int[]arr = {3,1,4,6,5,8,7};
//        System.out.println(maxChunksToSortedII(arr));

//        int[]arr={1,2,5,6,7,2};
//        System.out.println(minSubArrayLen(7,arr));

        int[]arr = {1,2,3,1,2,3};
        System.out.println(containsNearbyDuplicate(arr,2));

    }


    static void rotateK(int[]arr,int k){
        for (int j = 0; j < k; j++) {
            int temp = arr[0];
            for (int i = 0; i < arr.length - 1; i++) {
                arr[i] = arr[i + 1];
            }
            arr[arr.length - 1] = temp;
        }
        System.out.println(Arrays.toString(arr));
    }


    // (n-k) times LR   ==  RR (Right Rotation)
    public int[][] multipleLeftRotation(int[] a, int[] b) {
        int n= a.length;
        int m=b.length;
        int[][]ans=new int[m][n];

        // 2x ans print -> 1,2,3,4,5, 1,2,3,4,5
        int[]temp=new int[n*2];
        for (int i = 0; i < n; i++) {
            temp[i]=a[i];
            temp[n+i]=a[i];
        }

        for (int i = 0; i < m; i++) {
            int offset = b[i]%n;
            for (int j = 0; j < n; j++) {
                ans[i][j]=temp[j+offset];
            }
        }
        return ans;
    }





    public static ArrayList<Integer> wave(ArrayList<Integer> a) {
        Collections.sort(a);
//        System.out.println(a);
        for (int i = 1; i < a.size(); i+=2) {
            swap(a,i,i-1);
        }
        return a;
    }
    private static void swap(ArrayList<Integer> a, int i, int j) {
        int temp = a.get(i);
        a.set(i, a.get(j));
        a.set(j, temp);
    }
    public static ArrayList<Integer> waveNonLexo(ArrayList<Integer>a){
        for (int i = 1; i < a.size()-1; i+=2) {
            if(a.get(i)>a.get(i-1)) swap(a,i,i-1);
            if(a.get(i)>a.get(i+1)) swap(a,i,i+1);
        }
        return a;
    }

    public static List<List< Integer>> minimumAbsDifference(int[] arr){
        List<List<Integer>>ans=new ArrayList<>();
        Arrays.sort(arr);
        int minDiff = Integer.MAX_VALUE;
        ArrayList<Integer>diff=new ArrayList<>();
        for (int i = 1; i < arr.length; i++) {
            minDiff=Math.min(minDiff , arr[i]-arr[i-1]);
        }
        for (int i = 1; i < arr.length; i++) {
            if(minDiff==arr[i]-arr[i-1]){
                List<Integer>temp = new ArrayList<>();
                temp.add(arr[i-1]);
                temp.add(arr[i]);
                ans.add(temp);
            }
        }
        return ans;
    }

    // 1,2,1,0,0,2,1,0,2,1,0,2,1,0
    public static  int[] DNFsort(int[]arr){
        int low = 0;
        int mid = 0;
        int high = arr.length-1;

        while(mid<=high){
            if(arr[mid]==2){
                arr[mid]=arr[high];
                arr[high]=2;
                high--;
            }else if(arr[mid]==0){
                arr[mid]=arr[low];
                arr[low]=0;
                mid++;low++;
            }else{ // m==1
                mid++;
            }
        }
        return arr;
    }




    public static int maxChunksToSorted(int[] arr) {
        if(arr.length==0) return 0;

        int cnt=0;
        int maxSoFar=arr[0];

        for (int i = 0; i < arr.length; i++) {
            maxSoFar=Math.max(maxSoFar,arr[i]);
            if(i==maxSoFar) cnt++;
        }
        return cnt;
    }

    public static int maxChunksToSortedII(int[] arr){
        int n = arr.length;
        int cnt = 0;
        int[]left = new int[n];
        int[]right = new int[n];
        left[0] = arr[0];
        right[n-1] = arr[n-1];

        for (int i = 1; i < n; i++) {
            left[i] = Math.max(left[i-1],arr[i]);
        }
        for (int i = n-2; i >= 0; i--) {
            right[i] = Math.min(right[i+1],arr[i]);
        }


        for (int i = 0; i < n-1; i++) {
            if(left[i]<=right[i+1]){
                cnt++;
            }
        }

        return cnt+1;

    }



    static void Csort(int[] arr) {
        int i = 0;
        while (i < arr.length) {
            int correct = arr[i];
            if (arr[i] != arr[correct]) {
                swap(arr, i , correct);
            } else {
                i++;
            }
        }
    }
    static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }


    // Maximum Sum Sub Array --> Kadane's Algo
    // below (Minimum Sum Sub Array)
    public static int minSubArrayLen(int k, int[] a){
        int l=0,r=0;
        int currSum=0;
        int minLen=Integer.MAX_VALUE;
        while(r<a.length){
            currSum+=a[r];
            while(currSum>=k){
                minLen=Math.min(minLen,r-l+1);
                currSum -= a[l];
                l++;
            }
            r++;
        }
        if(minLen==Integer.MAX_VALUE){
            minLen=0;
        }
        return minLen;
    }

    public static boolean containsNearbyDuplicate(int[] arr, int k) {
        int n = arr.length;
        // for (int i = 0; i < n - 1; i++) {
        //     for (int j = i + 1; j < n; j++) {
        //         if (arr[i] == arr[j]){
        //             if(Math.abs(i-j)<=k)
        //             return true;
        //         }
        //     }
        // }
        // return false;
        // ----------------------------------------
        // HashSet<Integer>set=new HashSet<>();
        // for(int i=0;i<n;i++){
        //     if(i>k) set.remove(arr[i-k-1]); // extra line
        //     if(set.contains(arr[i])) return true;
        //     set.add(arr[i]);
        // }
        // return false;
        // ----------------------------------------
        Map<Integer,Integer>map=new HashMap<>();
        for(int i=0;i<n;i++){
            // if(map.containsKey(e) && map.get(e)>=1)
            if(map.containsKey(arr[i]) && i-map.get(arr[i])<=k){
                return true;
            }
            // map.put(e, map.getOrDefault(e,0)+1);
            map.put(arr[i],i);
        }
        return false;
    }


    //min ops to make all element equal to matrix
    public static int minOperations(int n, int m, int k, int[][]arr){

    }



}
